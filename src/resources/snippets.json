{ 
  
    "C++ Solve Function": {
      "prefix": "solve",
      "body": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "#define int int64_t",
        "",
        "void solve() {",
        "  ",
        "}",
        "",
        "signed main () {",
        "  ios::sync_with_stdio(false);",
        "  cin.tie(nullptr);",
        "  int t = 1;",
        "  // cin >> t;",
        "  while (t--) {",
        "    solve();",
        "  }",
        "  return 0;",
        "}"
      ],
      "description": "C++ Competitive Programming Template",
      "scope": "cpp"
    },
  
    "dsu": {
      "prefix": "dsu",
      "body": [
        "class dsu {",
        " public:",
        "  vector<int> p;",
        "  vector<int> sz;",
        "  int n;",
        "",
        "  dsu(int _n) : n(_n) {",
        "    p.resize(n);",
        "    sz.resize(n);",
        "    iota(p.begin(), p.end(), 0);",
        "    fill(sz.begin(), sz.end(), 1);",
        "  }",
        "",
        "  inline int get(int x) {",
        "    return (x == p[x] ? x : (p[x] = get(p[x])));",
        "  }",
        "",
        "  inline bool unite(int x, int y) {",
        "    x = get(x);",
        "    y = get(y);",
        "    if (sz[x] < sz[y]) swap(x, y);",
        "    if (x != y) {",
        "      p[y] = x;",
        "      sz[x] += sz[y];",
        "      return true;",
        "    }",
        "    return false;",
        "  }",
        "};"
        
      ],
      "description": "dsu"
    },
    "mo": {
      "prefix": "mo",
      "body": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "#define int long long",
        "#define ll long long",
        "#define ld long double",
        "#define pi pair<int, int>",
        "#define vi vector<int>",
        "#define vvi vector<vector<int>>",
        "#define vpi vector<pi>",
        "#define pb push_back",
        "#define ar array",
        "#define all(a) (a).begin(), (a).end()",
        "#define rall(a) (a).rbegin(), (a).rend()",
        "",
        "const ll MOD = 1e9+7;",
        "const ll INF = 1e18;",
        "const ll MAX = 2e5+1;",
        "",
        "int bsz;",
        "struct Query {",
        "    int l, r, idx;",
        "    bool operator<(const Query& other) const {",
        "        if (l / bsz != other.l / bsz)",
        "            return l / bsz < other.l / bsz;",
        "        return r < other.r;",
        "    }",
        "};",
        "map<int, int> freq;",
        "",
        "void solve() {",
        "    int N, Q;",
        "    cin >> N >> Q;",
        "    vi v(N);",
        "    for (auto& x : v) cin >> x;",
        "    vector<Query> queries(Q);",
        "    bsz = sqrt((double)N) + 1;",
        "    for (int i = 0; i < Q; ++i) {",
        "        cin >> queries[i].l >> queries[i].r;",
        "        --queries[i].l, --queries[i].r;",
        "        queries[i].idx = i;",
        "    }",
        "    sort(all(queries));",
        "",
        "    int dist = 0, lf = 0, r = -1;",
        "    vi ans(Q);",
        "    int mx = 0;",
        "    for (const auto& q : queries) {",
        "        while (lf > q.l) {",
        "            --lf;",
        "            if (++freq[v[lf]] == 1) {",
        "                mx = max(v[lf], mx);",
        "            }",
        "        }",
        "        while (r < q.r) {",
        "            ++r;",
        "            if (++freq[v[r]] == 1) {",
        "                mx = max(v[r], mx);",
        "            }",
        "        }",
        "        while (lf < q.l) {",
        "            if (--freq[v[lf]] == 0) {",
        "                freq.erase(v[lf]);",
        "                if (v[lf] < mx) continue;",
        "                if (freq.size()) {",
        "                    auto it = freq.end();",
        "                    --it;",
        "                    mx = it->first;",
        "                }",
        "            }",
        "            ++lf;",
        "        }",
        "        while (r > q.r) {",
        "            if (--freq[v[r]] == 0) {",
        "                freq.erase(v[r]);",
        "                if (freq.size()) {",
        "                    auto it = freq.end();",
        "                    --it;",
        "                    mx = it->first;",
        "                }",
        "            }",
        "            --r;",
        "        }",
        "        ans[q.idx] = mx;",
        "    }",
        "    for (int i = 0; i < Q; ++i) cout << ans[i] << '\\n';",
        "}",
        "",
        "signed main() {",
        "    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
        "",
        "    int t = 1;",
        "    // cin >> t;",
        "    while (t--) solve();",
        "",
        "    return 0;",
        "}"
      ],
      "description": "mo"
    },
    "lis": {
      "prefix": "lis",
      "body": [
        "int lis(vector<int>& v) {",
        "  vector<int> lis;",
        "  for (auto x : v) {",
        "    auto it = lower_bound(lis.begin(), lis.end(), x);",
        "    if (it == lis.end()) lis.push_back(x);",
        "    else *it = x;",
        "  }",
        "  return lis.size();",
        "}",
        "",
        "int lnds(vector<int>& v) {",
        "  vector<int> lnds;",
        "  for (auto x : v) {",
        "    auto it = upper_bound(lnds.begin(), lnds.end(), x);",
        "    if (it == lnds.end()) lnds.push_back(x);",
        "    else *it = x;",
        "  }",
        "  return lnds.size();",
        "}"
      ],
      "description": "lis"
    },
    "pbds": {
      "prefix": "pbds",
      "body": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "#include <ext/pb_ds/assoc_container.hpp>",
        "#include <ext/pb_ds/tree_policy.hpp>",
        "using namespace __gnu_pbds;",
        "",
        "template<class T> using oset = tree<T, null_type, less<T>, rb_tree_tag,",
        "                              tree_order_statistics_node_update>;",
        "",
        "#define int int64_t",
        "",
        "void solve() {",
        "  oset<int> o;",
        "  o.insert(3);",
        "  o.insert(3); // no duplicate",
        "  o.insert(4);",
        "  o.insert(5);",
        "  cout << o.order_of_key(5) << '\\n';",
        "  cout << *o.find_by_order(1) << '\\n'; // returns iterator",
        "}",
        "",
        "signed main () {",
        "  ios::sync_with_stdio(false);",
        "  cin.tie(nullptr);",
        "  int t = 1;",
        "  // cin >> t;",
        "  while (t--) {",
        "    solve();",
        "  }",
        "  return 0;",
        "}"
      ],
      "description": "pbds"
    },
    "simple_seg": {
      "prefix": "simple_seg",
      "body": [
        "constexpr int INF = 1ll << 61;",
        "",
        "#define lch (i << 1)",
        "#define rch (i << 1 | 1)",
        "",
        "struct Info {",
        "  int sum;",
        "  int mn;",
        "  int mx;",
        "",
        "  Info() : sum(0), mn(INF), mx(-INF) {}",
        "  Info(int x) : sum(x), mn(x), mx(x) {}",
        "",
        "  Info unite(const Info& b) {",
        "    Info res;",
        "    res.sum = sum + b.sum;",
        "    res.mn = min(mn, b.mn);",
        "    res.mx = max(mx, b.mx);",
        "    return res;",
        "  }",
        "};",
        "",
        "struct SimpleSegmentTree {",
        "",
        "  int n;",
        "  vector<Info> info;",
        "  SimpleSegmentTree(vector<Info>& a) : n(1 << (32 - __builtin_clz(a.size() - 1))) {",
        "    info.resize(n << 1);",
        "    for (int i = 0; i < a.size(); ++i) {",
        "      info[i + n] = a[i];",
        "    }",
        "    for (int i = n - 1; i > 0; --i) {",
        "      info[i] = info[lch].unite(info[rch]);",
        "    }",
        "  }",
        "",
        "  void apply(Info& a, int val) {",
        "    a.sum += val;",
        "    a.mn += val;",
        "    a.mx += val;",
        "  }",
        "",
        "  void modify(int i, int val) {",
        "    i += n;",
        "    apply(info[i], val);",
        "    i >>= 1;",
        "    while (i >= 1) {",
        "      info[i] = info[lch].unite(info[rch]);",
        "      i >>= 1;",
        "    }",
        "  }",
        "",
        "  Info query(int l, int r) {",
        "    l += n;",
        "    r += n;",
        "    Info res;",
        "    while (l <= r) {",
        "      if (l & 1) {",
        "        res = res.unite(info[l++]);",
        "      }",
        "      if (~r & 1) {",
        "        res = res.unite(info[r--]);",
        "      }",
        "      l >>= 1, r >>= 1;",
        "    }",
        "    return res;",
        "  }",
        "",
        "  int bs(int ql, int qr, int x, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    if (nr < ql || nl > qr || info[i].mx < x) {",
        "      return -1;",
        "    }",
        "    if (nl == nr) {",
        "      return nr;",
        "    }",
        "    int m = (nl + nr) >> 1;",
        "    int res = bs(ql, qr, x, lch, nl, m);",
        "    if (res != -1) {",
        "      return res;",
        "    }",
        "    return bs(ql, qr, x, rch, m + 1, nr);",
        "  }",
        "};"
      ],
      "description": "simple_seg"
    },
    "lazy_seg_both": {
      "prefix": "lazy_seg_both",
      "body": [
        "",
        "constexpr int INF = 1ll << 61;",
        "",
        "#define lch (i << 1)",
        "#define rch (i << 1 | 1)",
        "",
        "struct Info {",
        "  int sum;",
        "  int mn;",
        "  int mx;",
        "",
        "  Info() : sum(0), mn(INF), mx(-INF) {}",
        "  Info(int x) : sum(x), mn(x), mx(x) {}",
        "",
        "  Info unite(const Info& b) {",
        "    Info res;",
        "    res.sum = sum + b.sum;",
        "    res.mn = min(mn, b.mn);",
        "    res.mx = max(mx, b.mx);",
        "    return res;",
        "  }",
        "};",
        "",
        "struct Tag {",
        "  int delta = 0;",
        "  int put = -1;",
        "  Tag() : put(-1), delta(0) {}",
        "",
        "  void apply(Info& a, int nl, int nr) {",
        "    if (put != -1) {",
        "      a.sum = (nr - nl + 1) * put;",
        "      a.mn = a.mx = put;",
        "    } else if (delta) {",
        "      a.sum += delta * (nr - nl + 1);",
        "      a.mn += delta;",
        "      a.mx += delta;",
        "    }",
        "  }",
        "};",
        "",
        "struct LazySegmentTree {",
        "  int n;",
        "  vector<Info> info;",
        "  vector<Tag> tag;",
        "",
        "  LazySegmentTree(vector<Info>& a) : n(1 << (32 - __builtin_clz(a.size() - 1))) {",
        "    info.resize(n << 1);",
        "    tag.resize(n << 1);",
        "    for (int i = 0; i < a.size(); ++i) {",
        "      info[i + n] = a[i];",
        "    }",
        "    for (int i = n - 1; i > 0; --i) {",
        "      info[i] = info[lch].unite(info[rch]);",
        "    }",
        "  }",
        "",
        "  void push(int i, int nl, int nr) {",
        "    if (tag[i].put != -1) {",
        "      tag[i].apply(info[i], nl, nr);",
        "      if (nl != nr) {",
        "        tag[lch].put = tag[rch].put = tag[i].put;",
        "        tag[lch].delta = tag[rch].delta = 0;",
        "      }",
        "      tag[i].put = -1;",
        "    }",
        "    if (tag[i].delta) {",
        "      tag[i].apply(info[i], nl, nr);",
        "      if (nl != nr) {",
        "        if (tag[lch].put != -1) {",
        "          tag[lch].put += tag[i].delta;",
        "        } else {",
        "          tag[lch].delta += tag[i].delta;",
        "        }",
        "        if (tag[rch].put != -1) {",
        "          tag[rch].put += tag[i].delta;",
        "        } else {",
        "          tag[rch].delta += tag[i].delta;",
        "        }",
        "      }",
        "      tag[i].delta = 0;",
        "    }",
        "}",
        "",
        "  void put(int ql, int qr, int val, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    push(i, nl, nr);",
        "    if (nl > qr || nr < ql) return;",
        "",
        "    if (nl >= ql && nr <= qr) {",
        "      tag[i].put = val;",
        "      push(i, nl, nr);",
        "      return;",
        "    }",
        "",
        "    int mid = (nl + nr) / 2;",
        "    put(ql, qr, val, lch, nl, mid);",
        "    put(ql, qr, val, rch, mid + 1, nr);",
        "",
        "    info[i] = info[lch].unite(info[rch]);",
        "  }",
        "",
        "  void add(int ql, int qr, int val, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    push(i, nl, nr);",
        "    if (nl > qr || nr < ql) return;",
        "",
        "    if (nl >= ql && nr <= qr) {",
        "      tag[i].delta += val;",
        "      push(i, nl, nr);",
        "      return;",
        "    }",
        "",
        "    int mid = (nl + nr) / 2;",
        "    add(ql, qr, val, lch, nl, mid);",
        "    add(ql, qr, val, rch, mid + 1, nr);",
        "",
        "    info[i] = info[lch].unite(info[rch]);",
        "  }",
        "",
        "  Info query(int ql, int qr, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    push(i, nl, nr);",
        "    if (nl > qr || nr < ql) {",
        "      return Info();",
        "    }",
        "    if (nl >= ql && nr <= qr) {",
        "      return info[i];",
        "    }",
        "",
        "    int mid = (nl + nr) >> 1;",
        "    Info a = query(ql, qr, lch, nl, mid);",
        "    Info b = query(ql, qr, rch, mid + 1, nr);",
        "",
        "    return a.unite(b);",
        "  }",
        "",
        "  int bs(int ql, int qr, int x, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    if (nr < ql || nl > qr || info[i].mx < x) {",
        "      return -1;",
        "    }",
        "    if (nl == nr) {",
        "      return nr;",
        "    }",
        "    push(i, nl, nr);",
        "    int m = (nl + nr) / 2;",
        "    int res = bs(ql, qr, x, lch, nl, m);",
        "    if (res != -1) {",
        "      return res;",
        "    }",
        "    return bs(ql, qr, x, rch, m + 1, nr);",
        "  }",
        "};"
      ],
      "description": "lazy_seg_both"
    },
    "lazy_seg_put": {
      "prefix": "lazy_seg_put",
      "body": [
        "constexpr int INF = 1ll << 61;",
        "",
        "#define lch (i << 1)",
        "#define rch (i << 1 | 1)",
        "",
        "struct Info {",
        "  int sum;",
        "  int mn;",
        "  int mx;",
        "",
        "  Info() : sum(0), mn(INF), mx(-INF) {}",
        "  Info(int x) : sum(x), mn(x), mx(x) {}",
        "",
        "  Info unite(const Info& b) {",
        "    Info res;",
        "    res.sum = sum + b.sum;",
        "    res.mn = min(mn, b.mn);",
        "    res.mx = max(mx, b.mx);",
        "    return res;",
        "  }",
        "};",
        "",
        "struct Tag {",
        "  int put = -1;",
        "  Tag() : put(-1) {}",
        "",
        "  void apply(Info& a, int nl, int nr) {",
        "    if (put != -1) {",
        "      a.sum = (nr - nl + 1) * put;",
        "      a.mn = a.mx = put;",
        "    }",
        "  }",
        "};",
        "",
        "struct LazySegmentTree {",
        "  int n;",
        "  vector<Info> info;",
        "  vector<Tag> tag;",
        "",
        "  LazySegmentTree(vector<Info>& a) : n(1 << (32 - __builtin_clz(a.size() - 1))) {",
        "    info.resize(n << 1);",
        "    tag.resize(n << 1);",
        "    for (int i = 0; i < a.size(); ++i) {",
        "      info[i + n] = a[i];",
        "    }",
        "    for (int i = n - 1; i > 0; --i) {",
        "      info[i] = info[lch].unite(info[rch]);",
        "    }",
        "  }",
        "",
        "  void push(int i, int nl, int nr) {",
        "    if (tag[i].put != -1) {",
        "      tag[i].apply(info[i], nl, nr);",
        "      if (nl ^ nr) {",
        "        tag[lch].put = tag[rch].put = tag[i].put;",
        "      }",
        "      tag[i].put = -1;",
        "    }",
        "  }",
        "",
        "  void modify(int ql, int qr, int val, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    push(i, nl, nr);",
        "    if (nl > qr || nr < ql) return;",
        "",
        "    if (nl >= ql && nr <= qr) {",
        "      tag[i].put = val;",
        "      push(i, nl, nr);",
        "      return;",
        "    }",
        "",
        "    int mid = (nl + nr) / 2;",
        "    modify(ql, qr, val, lch, nl, mid);",
        "    modify(ql, qr, val, rch, mid + 1, nr);",
        "",
        "    info[i] = info[lch].unite(info[rch]);",
        "  }",
        "",
        "  Info query(int ql, int qr, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    push(i, nl, nr);",
        "    if (nl > qr || nr < ql) {",
        "      return Info();",
        "    }",
        "    if (nl >= ql && nr <= qr) {",
        "      return info[i];",
        "    }",
        "",
        "    int mid = (nl + nr) >> 1;",
        "    Info a = query(ql, qr, lch, nl, mid);",
        "    Info b = query(ql, qr, rch, mid + 1, nr);",
        "",
        "    return a.unite(b);",
        "  }",
        "",
        "  int bs(int ql, int qr, int x, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    if (nr < ql || nl > qr || info[i].mx < x) {",
        "      return -1;",
        "    }",
        "    if (nl == nr) {",
        "      return nr;",
        "    }",
        "    push(i, nl, nr);",
        "    int m = (nl + nr) / 2;",
        "    int res = bs(ql, qr, x, lch, nl, m);",
        "    if (res != -1) {",
        "      return res;",
        "    }",
        "    return bs(ql, qr, x, rch, m + 1, nr);",
        "  }",
        "};"
      ],
      "description": "lazy_seg_put"
    },
    "fenwick_2d": {
      "prefix": "fenwick_2d",
      "body": [
        "struct BIT2D {",
        "  vector<vector<int>> bit;",
        "  int n, m; // give + 1",
        "",
        "  BIT2D(int n, int m) : n(n), m(m) {",
        "    bit.assign(n, vector<int>(m, 0));",
        "  }",
        "",
        "  int sum(int x, int y) {",
        "    int ret = 0;",
        "    for (int i = x; i >= 0; i = (i & (i + 1)) - 1)",
        "      for (int j = y; j >= 0; j = (j & (j + 1)) - 1)",
        "        ret += bit[i][j];",
        "    return ret;",
        "  }",
        "",
        "  void add(int x, int y, int delta) {",
        "    for (int i = x; i < n; i = i | (i + 1)) {",
        "      for (int j = y; j < m; j = j | (j + 1))",
        "        bit[i][j] += delta;",
        "    }",
        "  }",
        "};"
      ],
      "description": "fenwick_2d"
    },
    "sparse_table_tourist": {
      "prefix": "sparse_table_tourist",
      "body": [
        "template <typename T, typename F>",
        "class SparseTable {",
        " public:",
        "  int n;",
        "  vector<vector<T>> mat;",
        "  F func;",
        "",
        "  SparseTable(const vector<T>& a, const F& f) : func(f) {",
        "    n = static_cast<int>(a.size());",
        "    int max_log = 32 - __builtin_clz(n);",
        "    mat.resize(max_log);",
        "    mat[0] = a;",
        "    for (int j = 1; j < max_log; j++) {",
        "      mat[j].resize(n - (1 << j) + 1);",
        "      for (int i = 0; i <= n - (1 << j); i++) {",
        "        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);",
        "      }",
        "    }",
        "  }",
        "",
        "  T get(int from, int to) const {",
        "    assert(0 <= from && from <= to && to <= n - 1);",
        "    int lg = 32 - __builtin_clz(to - from + 1) - 1;",
        "    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);",
        "  }",
        "};"
      ],
      "description": "sparse_table_tourist"
    },
    "fenwick": {
      "prefix": "fenwick",
      "body": [
        "template <typename T>",
        "class BIT {",
        "  std::vector<T> bit;",
        "  int n;",
        "  BIT(T size) {",
        "    n = size;",
        "    bit.assign(n + 1, 0);",
        "  }",
        "",
        "  void update(int idx, T delta) {",
        "    while (idx <= n) {",
        "      bit[idx] += delta;",
        "      idx += idx & -idx;",
        "    }",
        "  }",
        "",
        "  T query(int idx) {",
        "    T sum = 0;",
        "    while (idx > 0) {",
        "      sum += bit[idx];",
        "      idx -= idx & -idx;",
        "    }",
        "    return sum;",
        "  }",
        "",
        "  T range(int l, int r) {",
        "    return query(r) - query(l - 1);",
        "  }",
        "};"
      ],
      "description": "fenwick"
    },
    "fenwick_range": {
      "prefix": "fenwick_range",
      "body": [
        "class BITR {",
        "public:",
        "  int N;",
        "  vector<int> B1, B2;",
        "",
        "  BITR(int size) : N(size), B1(size + 1, 0), B2(size + 1, 0) {}",
        "",
        "  void add(vector<int>& b, int idx, int x) {",
        "    for (; idx <= N; idx += idx & -idx) {",
        "      b[idx] += x;",
        "    }",
        "  }",
        "",
        "  void range_add(int l, int r, int x) {",
        "    add(B1, l, x);",
        "    add(B1, r + 1, -x);",
        "    add(B2, l, x * (l - 1));",
        "    add(B2, r + 1, -x * r);",
        "  }",
        "",
        "  int sum(const vector<int>& b, int idx) {",
        "    int total = 0;",
        "    for (; idx > 0; idx -= idx & -idx) {",
        "      total += b[idx];",
        "    }",
        "    return total;",
        "  }",
        "",
        "  int prefix_sum(int idx) {",
        "    return sum(B1, idx) * idx - sum(B2, idx);",
        "  }",
        "",
        "  int range_sum(int l, int r) {",
        "    return prefix_sum(r) - prefix_sum(l - 1);",
        "  }",
        "};"
      ],
      "description": "fenwick_range"
    },
    "lazy_seg_iterative": {
      "prefix": "lazy_seg_iterative",
      "body": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "#define int int64_t",
        "",
        "constexpr int inf = 1ll << 61;",
        "",
        "struct Info {",
        "  int sum;",
        "  int mx;",
        "  int mn;",
        "",
        "  Info() : sum(0), mn(inf), mx(-inf) {}",
        "  Info(int x) : sum(x), mn(x), mx(x) {}",
        "",
        "  Info unite(const Info& b) {",
        "    Info res;",
        "    res.sum = sum + b.sum;",
        "    res.mn = min(mn, b.mn);",
        "    res.mx = max(mx, b.mx);",
        "    return res;",
        "  }",
        "};",
        "",
        "struct Tag {",
        "  int put;",
        "  int delta;",
        "",
        "  Tag() : put(-1), delta(0) {}",
        "};",
        "",
        "struct LazySegmentTree {",
        "  int n, h;",
        "  vector<Info> infos;",
        "  vector<Tag> tags;",
        "",
        "  LazySegmentTree(vector<Info>& a) : n(a.size()) {",
        "    h = log2(n);",
        "    infos.resize(2 * n);",
        "    tags.resize(2 * n);",
        "    for (int i = 0; i < a.size(); ++i) {",
        "      infos[i + n] = a[i];",
        "    }",
        "    for (int i = n - 1; i > 0; --i) {",
        "      infos[i] = infos[i << 1].unite(infos[i << 1 | 1]);",
        "    }",
        "  }",
        "",
        "  Info query(int l, int r) {",
        "    l += n, r += n;",
        "    push(l);",
        "    push(r);",
        "    Info resL, resR;",
        "    for (; l <= r; l >>= 1, r >>= 1) {",
        "      if (l & 1) resL = resL.unite(infos[l++]);",
        "      if (~r & 1) resR = infos[r--].unite(resR);",
        "    }",
        "    return resL.unite(resR);",
        "  }",
        "",
        "  void push(int p)  {",
        "    int k = n >> 1;",
        "    for (int i = h; i > 0; --i, k >>= 1) {",
        "      int s = p >> i;",
        "      if (tags[s].delta != 0) {",
        "        apply(s << 1, tags[s].delta, k);",
        "        apply(s << 1 | 1, tags[s].delta, k);",
        "        tags[s].delta = 0;",
        "      } else if (tags[s].put != -1) {",
        "        apply(s << 1, tags[s].delta, k);",
        "        apply(s << 1 | 1, tags[s].delta, k);",
        "        tags[s].put = -1;",
        "      }",
        "    }",
        "  }",
        "",
        "  void apply(int i, int val, int rng) {",
        "    infos[i].sum += val * rng;",
        "    infos[i].mn += val;",
        "    infos[i].mx += val;",
        "    if (i < n) tags[i].delta += val;",
        "    // infos[i].sum = val * rng;",
        "    // infos[i].mn = val;",
        "    // infos[i].mx = val;",
        "    // if (i < n) tags[i].delta = val;",
        "  }",
        "",
        "  void modify(int l, int r, int val) {",
        "    l += n, r += n;",
        "    int k = 1;",
        "    push(l);",
        "    push(r);",
        "    for (; l <= r; l >>= 1, r >>= 1, k <<= 1) {",
        "      if (l & 1) {",
        "        apply(l++, val, k);",
        "      }",
        "      if (~r & 1) {",
        "        apply(r--, val, k);",
        "      }",
        "    }",
        "  }",
        "",
        "  void set(int l, int r, int val) {",
        "    l += n, r += n;",
        "    int k = 1;",
        "    push(l);",
        "    push(r);",
        "    for (; l <= r; l >>= 1, r >>= 1, k <<= 1) {",
        "      if (l & 1) {",
        "        apply(l++, val, k);",
        "      }",
        "      if (~r & 1) {",
        "        apply(r--, val, k);",
        "      }",
        "    }",
        "  }",
        "};",
        "",
        "void solve() {",
        "  int N, Q;",
        "  cin >> N >> Q;",
        "  vector<int> arr(N);",
        "  vector<Info> infos(N);",
        "  for (int i = 0; i < N; ++i) {",
        "    cin >> arr[i];",
        "    infos[i] = {arr[i]};",
        "  }",
        "  LazySegmentTree st(infos);",
        "  while (Q--) {",
        "    int q;",
        "    cin >> q;",
        "    if (q == 1) {",
        "      int l, r, x;",
        "      cin >> l >> r >> x;",
        "      --l, --r;",
        "      st.modify(l, r, x);",
        "    } else {",
        "      int k;",
        "      cin >> k;",
        "      --k;",
        "      cout << st.query(k, k).sum << '\\n';",
        "    }",
        "  }",
        "}",
        "",
        "signed main () {",
        "  ios::sync_with_stdio(false);",
        "  cin.tie(nullptr);",
        "  int t = 1;",
        "  // cin >> t;",
        "  while (t--) {",
        "    solve();",
        "  }",
        "  return 0;",
        "}"
      ],
      "description": "lazy_seg_iterative"
    },
    "lazy_seg_add": {
      "prefix": "lazy_seg_add",
      "body": [
        "constexpr int INF = 1ll << 61;",
        "",
        "#define lch (i << 1)",
        "#define rch (i << 1 | 1)",
        "",
        "struct Info {",
        "  int sum;",
        "  int mn;",
        "  int mx;",
        "",
        "  Info() : sum(0), mn(INF), mx(-INF) {}",
        "  Info(int x) : sum(x), mn(x), mx(x) {}",
        "",
        "  Info unite(const Info& b) {",
        "    Info res;",
        "    res.sum = sum + b.sum;",
        "    res.mn = min(mn, b.mn);",
        "    res.mx = max(mx, b.mx);",
        "    return res;",
        "  }",
        "};",
        "",
        "struct Tag {",
        "  int delta = 0;",
        "  int put = -1;",
        "  Tag() : put(-1), delta(0) {}",
        "",
        "  void apply(Info& a, int nl, int nr) {",
        "    a.sum += (delta * (nr - nl + 1));",
        "    a.mn += delta;",
        "    a.mx += delta;",
        "  }",
        "};",
        "",
        "struct LazySegmentTree {",
        "  int n;",
        "  vector<Info> info;",
        "  vector<Tag> tag;",
        "  LazySegmentTree(vector<Info>& a) : n(1 << (32 - __builtin_clz(a.size() - 1))) {",
        "    info.resize(n << 1);",
        "    tag.resize(n << 1);",
        "    for (int i = 0; i < a.size(); ++i) {",
        "      info[i + n] = a[i];",
        "    }",
        "    for (int i = n - 1; i > 0; --i) {",
        "      info[i] = info[lch].unite(info[rch]);",
        "    }",
        "  }",
        "",
        "  void push(int i, int nl, int nr) {",
        "    if (tag[i].delta == 0) return;",
        "    tag[i].apply(info[i], nl, nr);",
        "    if (nl ^ nr) {",
        "      tag[lch].delta += tag[i].delta;",
        "      tag[rch].delta += tag[i].delta;",
        "    }",
        "    tag[i].delta = 0;",
        "  }",
        "",
        "  void modify(int ql, int qr, int val, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    push(i, nl, nr);",
        "    if (nl > qr || nr < ql) return;",
        "",
        "    if (nl >= ql && nr <= qr) {",
        "      tag[i].delta += val;",
        "      push(i, nl, nr);",
        "      return;",
        "    }",
        "",
        "    int mid = (nl + nr) / 2;",
        "    modify(ql, qr, val, lch, nl, mid);",
        "    modify(ql, qr, val, rch, mid+1, nr);",
        "",
        "    info[i] = info[lch].unite(info[rch]);",
        "  }",
        "",
        "  Info query(int ql, int qr, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    push(i, nl, nr);",
        "    if (nl > qr || nr < ql) {",
        "      return Info();",
        "    }",
        "    if (nl >= ql && nr <= qr) {",
        "      return info[i];",
        "    }",
        "    int mid = (nl + nr) >> 1;",
        "    Info a = query(ql, qr, lch, nl, mid);",
        "    Info b = query(ql, qr, rch, mid + 1, nr);",
        "",
        "    return a.unite(b);",
        "  }",
        "",
        "  int bs(int ql, int qr, int x, int i = 1, int nl = 0, int nr = -1) {",
        "    if (nr == -1) nr = n - 1;",
        "    push(i, nl, nr);",
        "    if (nr < ql || nl > qr || info[i].mx < x) {",
        "      return -1;",
        "    }",
        "    if (nl == nr) {",
        "      return nr;",
        "    }",
        "    int m = (nl + nr) / 2;",
        "    int res = bs(ql, qr, x, lch, nl, m);",
        "    if (res != -1) {",
        "      return res;",
        "    }",
        "    return bs(ql, qr, x, rch, m + 1, nr);",
        "  }",
        "};"
      ],
      "description": "lazy_seg_add"
    },
    "seg2d": {
      "prefix": "seg2d",
      "body": [
        "#include <iostream>",
        "#include <vector>",
        "",
        "using namespace std;",
        "",
        "const int MAX = 1001;",
        "int n, m, q;",
        "",
        "vector<vector<int>> a(MAX, vector<int>(MAX));",
        "vector<vector<int>> t(4 * MAX, vector<int>(4 * MAX));",
        "",
        "void build_y(int vx, int lx, int rx, int vy, int ly, int ry) {",
        "    if (ly == ry) {",
        "        if (lx == rx)",
        "            t[vx][vy] = a[lx][ly];",
        "        else",
        "            t[vx][vy] = t[vx*2][vy] + t[vx*2 + 1][vy];",
        "    } else {",
        "        int my = (ly + ry) / 2;",
        "        build_y(vx, lx, rx, vy*2, ly, my);",
        "        build_y(vx, lx, rx, vy*2 + 1, my+1, ry);",
        "        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2 + 1];",
        "    }",
        "}",
        "",
        "void build_x(int vx, int lx, int rx) {",
        "    if (lx != rx) {",
        "        int mx = (lx + rx) / 2;",
        "        build_x(vx*2, lx, mx);",
        "        build_x(vx*2 + 1, mx+1, rx);",
        "    }",
        "    build_y(vx, lx, rx, 1, 0, m - 1);",
        "}",
        "",
        "int sum_y(int vx, int vy, int tly, int try_, int ly, int ry) {",
        "    if (ly > ry)",
        "        return 0;",
        "    if (ly == tly && try_ == ry)",
        "        return t[vx][vy];",
        "    int tmy = (tly + try_) / 2;",
        "    return sum_y(vx, vy * 2, tly, tmy, ly, min(ry, tmy)) +",
        "           sum_y(vx, vy * 2 + 1, tmy + 1, try_, max(ly, tmy + 1), ry);",
        "}",
        "",
        "int sum_x(int vx, int tlx, int trx, int lx, int rx, int ly, int ry) {",
        "    if (lx > rx)",
        "        return 0;",
        "    if (lx == tlx && trx == rx)",
        "        return sum_y(vx, 1, 0, m - 1, ly, ry);",
        "    int tmx = (tlx + trx) / 2;",
        "    return sum_x(vx*2, tlx, tmx, lx, min(rx, tmx), ly, ry) +",
        "           sum_x(vx*2 + 1, tmx + 1, trx, max(lx, tmx+1), rx, ly, ry);",
        "}",
        "",
        "void update_y(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int new_val) {",
        "    if (ly == ry) {",
        "        if (lx == rx)",
        "            t[vx][vy] = new_val;",
        "        else",
        "            t[vx][vy] = t[vx*2][vy] + t[vx*2 + 1][vy];",
        "    } else {",
        "        int my = (ly + ry) / 2;",
        "        if (y <= my)",
        "            update_y(vx, lx, rx, vy * 2, ly, my, x, y, new_val);",
        "        else",
        "            update_y(vx, lx, rx, vy * 2 + 1, my + 1, ry, x, y, new_val);",
        "        t[vx][vy] = t[vx][vy*2] + t[vx][vy*2 + 1];",
        "    }",
        "}",
        "",
        "void update_x(int vx, int lx, int rx, int x, int y, int new_val) {",
        "    if (lx != rx) {",
        "        int mx = (lx+rx) / 2;",
        "        if (x <= mx)",
        "            update_x(vx*2, lx, mx, x, y, new_val);",
        "        else",
        "            update_x(vx*2 + 1, mx+1, rx, x, y, new_val);",
        "    }",
        "    update_y(vx, lx, rx, 1, 0, m-1, x, y, new_val);",
        "}",
        "",
        "void print() {",
        "",
        "    for (int i = 0; i < n*2; ++i) {",
        "        for (int j = 0; j < m*2; ++j) {",
        "            cout << t[i][j] << ' ';",
        "        }",
        "        cout << '\\n';",
        "    }",
        "}",
        "int main() {",
        "    cin >> n >> m >> q;",
        "    for (int i = 0; i < n; ++i)",
        "        for (int j = 0; j < m; ++j)",
        "            cin >> a[i][j];",
        "",
        "    build_x(1, 0, n - 1);",
        "",
        "    while (q--) {",
        "        int qry; cin >> qry;",
        "        if (qry == 1) {",
        "",
        "            int x1, y1, x2, y2;",
        "            cin >> x1 >> y1 >> x2 >> y2;",
        "            int sum = sum_x(1, 0, n-1, x1, x2, y1, y2);",
        "            cout << sum << '\\n';",
        "        }",
        "        else {",
        "            int x1, y1, val;",
        "            cin >> x1 >> y1 >> val;",
        "            update_x(1, 0, n-1, x1, y1, val);",
        "        }",
        "        print();",
        "    }",
        "",
        "    return 0;",
        "}"
      ],
      "description": "seg2d"
    },
    "lca_b_lifting": {
      "prefix": "lca_b_lifting",
      "body": [
        "auto ancestor = [&](int u, int v) -> bool {",
        "    return u == 0 || (in[u] <= in[v] && out[u] >= out[v]);",
        "  };",
        "  auto dist = [&](int u, int v) -> int {",
        "    if (u == v) return 0;",
        "    int dis = 0;",
        "    for (int i = 19; ~i; --i) {",
        "      if (!ancestor(par[v][i][0], u)) {",
        "        dis += par[v][i][1];",
        "        v = par[v][i][0];",
        "      }",
        "    }",
        "    return dis + par[v][0][1];",
        "  };",
        "  auto lca = [&](int u, int v) -> int {",
        "    for (int j = 19; ~j; --j) {",
        "      if (!ancestor(par[u][j][0], v)) {",
        "        u = par[u][j][0];",
        "      }",
        "      if (!ancestor(par[v][j][0], u)) {",
        "        v = par[v][j][0];",
        "      }",
        "    }",
        "    if (!ancestor(u, v)) {",
        "      return par[u][0][0];",
        "    }",
        "    return par[v][0][0];",
        "  };"
      ],
      "description": "lca_b_lifting"
    },
    "bridge": {
      "prefix": "bridge",
      "body": [
        "vector<int> tin;",
        "vector<int> low;",
        "vector<bool> vis;",
        "vector<vector<int>> adj;",
        "int timer = -1;",
        "",
        "void bridge(int u, int p = -1) {",
        "  vis[u] = 1;",
        "  tin[u] = low[u] = ++timer;",
        "  for (auto& v : adj[u]) {",
        "    if (v == p) continue;",
        "    if (vis[v]) {",
        "      low[u] = min(low[u], tin[v]);",
        "    } else {",
        "      bridge(v, u);",
        "      low[u] = min(low[u], low[v]);",
        "      if (low[v] > tin[u]) {",
        "        //",
        "      }",
        "    }",
        "  }",
        "}"
      ],
      "description": "bridge"
    },
    "scc": {
      "prefix": "scc",
      "body": [
        "int N, M;",
        "vector<bool> vis;",
        "vector<vector<int>> adj, rev;",
        "vector<vector<int>> comps;",
        "vector<bool> cyc;",
        "",
        "void dfs(int u, vector<vector<int>>& G, vector<int>& output) {",
        "  vis[u] = true;",
        "  for (auto v : G[u]) {",
        "    if (!vis[v]) {",
        "      dfs(u, G, output);",
        "    }",
        "  }",
        "  output.push_back(u);",
        "}",
        "",
        "void scc() {",
        "  vector<int> order;",
        "  for (int i = 1; i <= N; i++) {",
        "    if (!vis[i]) {",
        "      dfs(i, adj, order);",
        "    }",
        "  }",
        "  vis.assign(N, 0);",
        "  reverse(order.begin(), order.end());",
        "  for (auto u : order) {",
        "    if (vis[u]) continue;",
        "    vector<int> comp;",
        "    dfs(u, rev, comp);",
        "    sort(comp.begin(), comp.end());",
        "    comps.push_back(comp);",
        "  }",
        "}"
      ],
      "description": "scc"
    },
    "kmp": {
      "prefix": "kmp",
      "body": [
        "vector<int> kmp(string s) {",
        "  int n = (int)s.length();",
        "  vector<int> pi(n);",
        "  for (int i = 1; i < n; ++i) {",
        "    int j = pi[i - 1];",
        "    while (j > 0 && s[i] != s[j]) {",
        "      j = pi[j - 1];",
        "    }",
        "    if (s[i] == s[j]) {",
        "      j++;",
        "    }",
        "    pi[i] = j;",
        "  }",
        "  return pi;",
        "}"
      ],
      "description": "kmp"
    },
    "trie_string_array": {
      "prefix": "trie_string_array",
      "body": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "constexpr int MAX = 1e6 + 100;",
        "int nxt[MAX][26];",
        "int cnt[MAX][26];",
        "",
        "struct trie {",
        "  int ptr;",
        "  trie() : ptr(0) {}",
        "  void insert(string& s) {",
        "    int p = 0;",
        "    for (int i = 0; i < s.size(); ++i) {",
        "      int c = s[i] - 'a';",
        "      if (!nxt[p][c]) {",
        "        nxt[p][c] = ++ptr;",
        "      }",
        "      ++cnt[p][c];",
        "      p = nxt[p][c];",
        "    }",
        "  }",
        "",
        "  int calc(string& s) {",
        "    int64_t ans = 0;",
        "    int p = 0;",
        "    for (int i = 0; i < s.size(); ++i) {",
        "      int c = s[i] - 'a';",
        "      if (!nxt[p][c]) {",
        "        break;",
        "      }",
        "      ans += cnt[p][c];",
        "      p = nxt[p][c];",
        "    }",
        "    return ans * 2;",
        "  }",
        "  // 00000000",
        "  // 00010000",
        "  // 00101010",
        "  // 00101110",
        "  // 10010101",
        "  // 01101010",
        "  int N;",
        "  int val[12321];",
        "  int f(int i, int mask) {",
        "     int ans = 0;",
        "    for (int j = 0; j < N; ++j) {",
        "      if ((mask >> j) & 1) {",
        "        continue;",
        "      }",
        "      ans = val[j] + max(ans, f(i + 1, mask | (1 << j)));",
        "    }",
        "    return ans;",
        "  }",
        "};",
        "",
        "void solve() {",
        "  int N;",
        "  cin >> N;",
        "  vector<string> arr(N);",
        "  trie t;",
        "  int64_t len = 0;",
        "  for (string& s : arr) {",
        "    cin >> s;",
        "    len += s.size();",
        "    t.insert(s);",
        "  }",
        "  int64_t ans = 0;",
        "  for (string& s : arr) {",
        "    ans += s.size() * N + len;",
        "    reverse(s.begin(), s.end());",
        "    ans -= t.calc(s);",
        "  }",
        "  cout << ans << '\\n';",
        "}",
        "",
        "signed main () {",
        "  ios::sync_with_stdio(false);",
        "  cin.tie(nullptr);",
        "  int t = 1;",
        "  // cin >> t;",
        "  while (t--) {",
        "    solve();",
        "  }",
        "  return 0;",
        "}"
      ],
      "description": "trie_string_array"
    },
    "hash": {
      "prefix": "hash",
      "body": [
        "constexpr int MOD = 1e9 + 7;",
        "constexpr int MAX = 1e5 + 1;",
        "",
        "int fp(int a, int b) {",
        "  int res = 1;",
        "  while (b > 0) {",
        "    if (b & 1) {",
        "      res = res * a % MOD;",
        "    }",
        "    a = a * a % MOD;",
        "    b >>= 1;",
        "  }",
        "  return res;",
        "}",
        "",
        "namespace Numeric {",
        "  mt19937 rng(chrono::high_resolution_clock().now().time_since_epoch().count());",
        "  static const int _n = 3;",
        "  static const array<int, _n> p = {1171, 1453, 1973};",
        "  static int pw[_n][MAX], inv[_n][MAX];",
        "  static int alp[26];",
        "",
        "  static bool init = []() {",
        "    iota(alp, alp + 26, 1);",
        "    shuffle(alp, alp + 26, rng);",
        "    for (int i = 0; i < _n; ++i) {",
        "      pw[i][0] = 1, inv[i][0] = 1;",
        "      for (int j = 1; j < MAX; ++j) {",
        "        pw[i][j] = pw[i][j - 1] * p[i] % MOD;",
        "        inv[i][j] = fp(pw[i][j], MOD - 2);",
        "      }",
        "    }",
        "    return true;",
        "  }();",
        "};",
        "using namespace Numeric;",
        "",
        "struct Hash {",
        "  array<int, _n> h;",
        "  Hash(char& c) {",
        "    for (int i = 0; i < _n; ++i) {",
        "      h[i] = alp[c - 'a'];",
        "    }",
        "  }",
        "  bool operator<(const Hash& other) const { return h < other.h; }",
        "  bool operator>(const Hash& other) const { return h > other.h; }",
        "  bool operator<=(const Hash& other) const { return h <= other.h; }",
        "  bool operator>=(const Hash& other) const { return h >= other.h; }",
        "  bool operator==(const Hash& other) const { return h == other.h; }",
        "  bool operator!=(const Hash& other) const { return h != other.h; }",
        "  void operator+=(Hash& other) { *this = *this + other; }",
        "  void operator-=(Hash& other) { *this = *this - other; }",
        "",
        "  Hash operator+(Hash& other) {",
        "    Hash res = *this;",
        "    for (int i = 0; i < _n; ++i) {",
        "      res.h[i] = (res.h[i] + other.h[i]) % MOD;",
        "    }",
        "    return res;",
        "  }",
        "",
        "  Hash operator-(Hash& other) {",
        "    Hash res = *this;",
        "    for (int i = 0; i < _n; ++i) {",
        "      res.h[i] = (res.h[i] - other.h[i] + MOD) % MOD;",
        "    }",
        "    return res;",
        "  }",
        "",
        "  Hash operator<<(int s) const {",
        "    Hash res = *this;",
        "    for (int i = 0; i < _n; ++i) {",
        "      res.h[i] = (res.h[i] * pw[i][s]) % MOD;",
        "    }",
        "    return res;",
        "  }",
        "",
        "  Hash operator>>(int s) const {",
        "    Hash res = *this;",
        "    for (int i = 0; i < _n; ++i) {",
        "      res.h[i] = (res.h[i] * inv[i][s]) % MOD;",
        "    }",
        "    return res;",
        "  }",
        "};",
        "",
        "struct Hasher {",
        "  vector<Hash> pref;",
        "  Hasher(string& s) {",
        "    for (int i = 0; i < s.size(); ++i) {",
        "      pref.emplace_back(Hash(s[i]) << i);",
        "      if (i) pref[i] += pref[i - 1];",
        "    }",
        "  }",
        "  Hash get(int l, int r) {",
        "    Hash res = pref[r];",
        "    if (l) {",
        "      res -= pref[l - 1];",
        "      res = res >> l;",
        "    }",
        "    return res;",
        "  }",
        "};"
      ],
      "description": "hash"
    },
    "suffix_array": {
      "prefix": "suffix_array",
      "body": [
        "// without '$', it sorts all cyclic shifts",
        "// with, it sorts all suffixes",
        "vector<int> sort_cyclic(string s) {",
        "  s += '$';",
        "  int n = s.size();",
        "  const int alp = 256;",
        "  vector<int> p(n), c(n), cnt(max(alp, n));",
        "  for (int i = 0; i < n; ++i) {",
        "    ++cnt[s[i]];",
        "  }",
        "  for (int i = 1; i < alp; ++i) {",
        "    cnt[i] += cnt[i - 1];",
        "  }",
        "  for (int i = 0; i < n; ++i) {",
        "    p[--cnt[s[i]]] = i;",
        "  }",
        "  c[p[0]] = 0;",
        "  int j = 1;",
        "  for (int i = 1; i < n; ++i) {",
        "    if (s[p[i]] != s[p[i - 1]]) {",
        "      ++j;",
        "    }",
        "    c[p[i]] = j - 1;",
        "  }",
        "  vector<int> pn(n), cn(n);",
        "  for (int h = 0; (1 << h) < n; ++h) {",
        "    for (int i = 0; i < n; ++i) {",
        "      pn[i] = p[i] - (1 << h);",
        "      if (pn[i] < 0) {",
        "        pn[i] += n;",
        "      }",
        "    }",
        "    fill(cnt.begin(), cnt.begin() + j, 0);",
        "    for (int i = 0; i < n; i++) {",
        "      cnt[c[pn[i]]]++;",
        "    }",
        "    for (int i = 1; i < j; i++) {",
        "      cnt[i] += cnt[i-1];",
        "    }",
        "    for (int i = n-1; i >= 0; i--) {",
        "      p[--cnt[c[pn[i]]]] = pn[i];",
        "    }",
        "    cn[p[0]] = 0;",
        "    j = 1;",
        "    for (int i = 1; i < n; i++) {",
        "      pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};",
        "      pair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};",
        "      if (cur != prev) {",
        "        ++j;",
        "      }",
        "      cn[p[i]] = j - 1;",
        "    }",
        "    c.swap(cn);",
        "  }",
        "  return p;",
        "}"
      ],
      "description": "suffix_array"
    },
    "trie_string": {
      "prefix": "trie_string",
      "body": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "#define int int64_t",
        "",
        "struct node {",
        "  node* nxt[26];",
        "  char val;",
        "  bool end = 0;",
        "};",
        "",
        "struct trie {",
        "  node* root;",
        "  trie() { root = new node(); }",
        "",
        "  void insert(string s) {",
        "    node* p = root;",
        "    for (int i = 0; i < s.size(); ++i) {",
        "      int c = s[i] - 'a';",
        "      if (!p->nxt[c]) p->nxt[c] = new node();",
        "      p = p->nxt[c];",
        "      if (i == s.size() - 1) {",
        "        p->end = 1;",
        "      }",
        "    }",
        "  }",
        "",
        "  void calc(string s) {",
        "    node* p = root;",
        "    for (int i = 0; i < s.size(); ++i) {",
        "      char c = s[i] - 'a';",
        "      p = p->nxt[c];",
        "      if (!p) break;",
        "      if (p->end) {",
        "",
        "      }",
        "    }",
        "  }",
        "};",
        "",
        "",
        "void solve() {",
        "",
        "}",
        "",
        "signed main () {",
        "  ios::sync_with_stdio(false);",
        "  cin.tie(nullptr);",
        "  int t = 1;",
        "  // cin >> t;",
        "  while (t--) {",
        "    solve();",
        "  }",
        "  return 0;",
        "}"
      ],
      "description": "trie_string"
    },
    "cht": {
      "prefix": "cht",
      "body": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "#define int int64_t",
        "",
        "struct line {",
        "\tint m, c;",
        "\tline(int m_, int c_) : m(m_), c(c_) {}",
        "};",
        "",
        "struct CHT {",
        "\tvector<line> lines;",
        "\tbool bad(line l1, line l2, line l3) {",
        "\t\t// m1x + c1, m2x + c2, m3x + c3;",
        "\t\t// m1x + c1 = m2x + c2",
        "\t\t// x1 = c2 - c1 / m1 - m2",
        "\t\t// m2x + c2 = m3x + c3",
        "\t\t// x2 = c3 - c2 / m2x - m3x",
        "\t\t// bad == x1 >= x2",
        "\t\t__int128 a = (__int128) (l2.c - l1.c) * (l2.m - l3.m);",
        "\t\t__int128 b = (__int128) (l3.c - l2.c) * (l1.m - l2.m);",
        "\t\treturn a >= b;",
        "\t}",
        "",
        "\tvoid add(line a) {",
        "\t\tlines.emplace_back(a);",
        "\t\tint sz = lines.size();",
        "\t\twhile (sz >= 3 && bad(lines[sz - 3], lines[sz - 2], lines[sz - 1])) {",
        "\t\t\tlines.erase(lines.end() - 2);",
        "\t\t\t--sz;",
        "\t\t}",
        "\t}",
        "",
        "\tinline int get(int idx, int x) {",
        "\t\treturn lines[idx].m * x + lines[idx].c;",
        "\t}",
        "",
        "\tint query(int x) {",
        "\t\tint lo = 0, hi = lines.size() - 1;",
        "\t\tint ans = 0;",
        "\t\twhile (lo <= hi) {",
        "\t\t\tint mi1 = lo + (hi - lo) / 3;",
        "\t\t\tint mi2 = hi - (hi - lo) / 3;",
        "\t\t\tif (get(mi1, x) <= get(mi2, x)) {",
        "\t\t\t\thi = mi2 - 1;",
        "\t\t\t\tans = get(mi1, x);",
        "\t\t\t} else {",
        "\t\t\t\tlo = mi1 + 1;",
        "\t\t\t\tans = get(mi2, x);",
        "\t\t\t}",
        "\t\t}",
        "\t\treturn ans;",
        "\t}",
        "",
        "};",
        "",
        "void solve() {",
        "  // jump j to i with cost (arr[i] - arr[j])^2 + C",
        "  int N, C;",
        "  cin >> N >> C;",
        "  vector<int> arr(N);",
        "  vector<int> dp(N);",
        "  for (int& x : arr) cin >> x;",
        "  CHT cht;",
        "  dp[0] = 0;",
        "  cht.add({-2 * arr[0], arr[0] * arr[0] + dp[0]});",
        "  for (int i = 1; i < N; ++i) {",
        "    dp[i] = C + arr[i] * arr[i] + cht.query(arr[i]);",
        "    cht.add({-2 * arr[i], arr[i] * arr[i] + dp[i]});",
        "  }",
        "  cout << dp[N - 1] << '\\n';",
        "}",
        "",
        "signed main () {",
        "\tios::sync_with_stdio(false);",
        "\tcin.tie(nullptr);",
        "\tint t = 1;",
        "\t// cin >> t;",
        "\twhile (t--) {",
        "\t\tsolve();",
        "\t}",
        "\treturn 0;",
        "}"
      ],
      "description": "cht"
    },
    "fast_pow": {
      "prefix": "fast_pow",
      "body": [
        "int fp(int a, int b) {",
        "  int res = 1;",
        "  while (b > 0) {",
        "    if (b & 1) {",
        "      res = res * a % MOD;",
        "    }",
        "    a = a * a % MOD;",
        "    b >>= 1;",
        "  }",
        "  return res;",
        "}"
      ],
      "description": "fast_pow"
    },
    "__builtin_functions": {
      "prefix": "__builtin_functions",
      "body": [
        "__builtin_popcountll(x); // Counts the number of 1-bits in a long long.",
        "__builtin_clzll(x); // Counts leading zeros in a long long.",
        "__builtin_ctzll(x); // Counts trailing zeros in a long long.",
        "__builtin_parityll(x); // Returns the parity of a long long.",
        "__builtin_ffsll(x); // Finds the 1-based index of the least significant 1-bit in a long long.",
        "__builtin_clrsbll(x); // Counts the leading redundant sign bits in a long long."
      ],
      "description": "__builtin_functions"
    },
    "sieve": {
      "prefix": "sieve",
      "body": [
        "vector<int> spf(MAX);",
        "vector<int> prs;",
        "",
        "void sieve() {",
        "\tfor (int i = 2; i < MAX; ++i) {",
        "\t\tif (spf[i]) {",
        "\t\t\tcontinue;",
        "\t\t}",
        "\t\tspf[i] = i;",
        "\t\tprs.emplace_back(i);",
        "\t\tfor (int j = i * i; j < MAX; j += i) {",
        "\t\t\tif (!spf[j]) {",
        "\t\t\t\tspf[j] = i;",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "}"
      ],
      "description": "sieve"
    },
    "euler_totient": {
      "prefix": "euler_totient",
      "body": [
        "#include <bits/stdc++.h>",
        "#define ii pair<int,int>",
        "",
        "using ll = long long;",
        "using namespace std;",
        "",
        "const int mod = 1e9 + 7;",
        "",
        "ll totient(ll n) {",
        "    int m = 1e6 + 5;",
        "    vector<bool> isPrime(m, true);",
        "    isPrime[0] = isPrime[1] = false;",
        "    vector<int> primes;",
        "    for(int i = 2; i <= n; i++) {",
        "        if(isPrime[i]){",
        "            primes.push_back(i);",
        "            for(int j = 2*i; j <=n; j += i) {",
        "                isPrime[j] = false;",
        "            }",
        "        }",
        "    }",
        "    ll ans = n;",
        "    bool flag = false;",
        "    for(int &x : primes) {",
        "        if(n % x == 0) {",
        "            ans /= x;",
        "            ans *= (x-1);",
        "            while(n % x == 0){",
        "                n /= x;",
        "            }",
        "        }",
        "    }",
        "    if(n != 1) {",
        "        ans /= n;",
        "        ans *= (n-1);",
        "    }",
        "    return ans;",
        "}",
        "",
        "int main() {",
        "    ios::sync_with_stdio(false);",
        "    cin.tie(NULL);",
        "",
        "    ll n; cin >> n;",
        "    cout << totient(n);",
        "",
        "    return 0;",
        "}"
      ],
      "description": "euler_totient"
    },
    "gcd_lcm": {
      "prefix": "gcd_lcm",
      "body": [
        "int gcd(int a, int b) {",
        "  while (b != 0) {",
        "    int temp = b;",
        "    b = a % b;",
        "    a = temp;",
        "  }",
        "  return a;",
        "}",
        "",
        "int lcm(int a, int b) {",
        "  return (a / gcd(a, b)) * b;",
        "}"
      ],
      "description": "gcd_lcm"
    },
    "hash_int": {
      "prefix": "hash_int",
      "body": [
        "constexpr int MOD = 1e9 + 7;",
        "constexpr int MAX = 1e6 + 1;",
        "",
        "int fp(int a, int b) {",
        "  int res = 1;",
        "  while (b > 0) {",
        "    if (b & 1) {",
        "      res = res * a % MOD;",
        "    }",
        "    a = a * a % MOD;",
        "    b >>= 1;",
        "  }",
        "  return res;",
        "}",
        "",
        "namespace Numeric {",
        "  mt19937 rng(chrono::high_resolution_clock().now().time_since_epoch().count());",
        "  static const int _n = 3;",
        "  static const array<int, _n> p = {1e9 + 7, 1e9 + 9, 998244353};",
        "  static int pw[_n][MAX], inv[_n][MAX];",
        "  static int alp[MAX];",
        "",
        "  static bool init = []() {",
        "    iota(alp, alp + MAX, 1);",
        "    shuffle(alp, alp + MAX, rng);",
        "    for (int i = 0; i < _n; ++i) {",
        "      pw[i][0] = 1, inv[i][0] = 1;",
        "      for (int j = 1; j < MAX; ++j) {",
        "        pw[i][j] = pw[i][j - 1] * p[i] % MOD;",
        "        inv[i][j] = fp(pw[i][j], MOD - 2);",
        "      }",
        "    }",
        "    return true;",
        "  }();",
        "};",
        "using namespace Numeric;",
        "",
        "struct Hash {",
        "  array<int, _n> h;",
        "  Hash(int x) {",
        "    for (int i = 0; i < _n; ++i) {",
        "      h[i] = alp[x];",
        "    }",
        "  }",
        "  bool operator<(const Hash& other) const { return h < other.h; }",
        "  bool operator>(const Hash& other) const { return h > other.h; }",
        "  bool operator<=(const Hash& other) const { return h <= other.h; }",
        "  bool operator>=(const Hash& other) const { return h >= other.h; }",
        "  bool operator==(const Hash& other) const { return h == other.h; }",
        "  bool operator!=(const Hash& other) const { return h != other.h; }",
        "  void operator+=(Hash& other) { *this = *this + other; }",
        "  void operator-=(Hash& other) { *this = *this - other; }",
        "",
        "  Hash operator+(Hash& other) {",
        "    Hash res = *this;",
        "    for (int i = 0; i < _n; ++i) {",
        "      res.h[i] = (res.h[i] + other.h[i]) % MOD;",
        "    }",
        "    return res;",
        "  }",
        "",
        "  Hash operator-(Hash& other) {",
        "    Hash res = *this;",
        "    for (int i = 0; i < _n; ++i) {",
        "      res.h[i] = (res.h[i] - other.h[i] + MOD) % MOD;",
        "    }",
        "    return res;",
        "  }",
        "",
        "  Hash operator<<(int s) const {",
        "    Hash res = *this;",
        "    for (int i = 0; i < _n; ++i) {",
        "      res.h[i] = (res.h[i] * pw[i][s]) % MOD;",
        "    }",
        "    return res;",
        "  }",
        "",
        "  Hash operator>>(int s) const {",
        "    Hash res = *this;",
        "    for (int i = 0; i < _n; ++i) {",
        "      res.h[i] = (res.h[i] * inv[i][s]) % MOD;",
        "    }",
        "    return res;",
        "  }",
        "};",
        "",
        "struct Hasher {",
        "  vector<Hash> pref;",
        "  Hasher(vector<int>& s) {",
        "    for (int i = 0; i < s.size(); ++i) {",
        "      pref.emplace_back(Hash(s[i]) << i);",
        "      if (i) pref[i] += pref[i - 1];",
        "    }",
        "  }",
        "  Hash get(int l, int r) {",
        "    Hash res = pref[r];",
        "    if (l) {",
        "      res -= pref[l - 1];",
        "      res = res >> l;",
        "    }",
        "    return res;",
        "  }",
        "};"
      ],
      "description": "hash_int"
    },
    "k_bits": {
      "prefix": "k_bits",
      "body": [
        "for (int msk = (1 << K) - 1; msk < (1 << N); ) {",
        "    if (!msk) break;",
        "    int x = msk & -msk, y = msk + x;",
        "    msk = (msk & ~y) / x >> 1 | y;",
        "}"
      ],
      "description": "k_bits"
    },
    "trie_bit_array": {
      "prefix": "trie_bit_array",
      "body": [
        "constexpr int MAX = 2e5 + 1;",
        "static int nxt[MAX * 31][2];",
        "static int cnt[MAX * 31][2];",
        "",
        "struct trie {",
        "  int bit;",
        "  int ptr;",
        "",
        "  trie() : bit(30), ptr(0) {}",
        "",
        "  void clear() {",
        "    for (int i = 0; i <= ptr; ++i) {",
        "      nxt[i][0] = nxt[i][1] = 0;",
        "    }",
        "  }",
        "",
        "  void insert(int val) {",
        "    int p = 0;",
        "    for (int i = bit; ~i; --i) {",
        "      int y = (val >> i) & 1;",
        "      if (!nxt[p][y]) {",
        "        nxt[p][y] = ++ptr;",
        "      };",
        "      ++cnt[p][y];",
        "      p = nxt[p][y];",
        "    }",
        "  }",
        "",
        "  void remove(int val) {",
        "    int p = 0;",
        "    for (int i = bit; ~i; --i) {",
        "      int y = (val >> i) & 1;",
        "      int ch = nxt[p][y];",
        "      if (nxt[p][y] == 1) {",
        "        nxt[p][y] = 0;",
        "      } else {",
        "        cnt[p][y];",
        "      }",
        "      p = ch;",
        "    }",
        "  }",
        "",
        "  int calc(int val) {",
        "    int p = 0;",
        "    int ans = 0;",
        "    for (int i = bit; ~i; --i) {",
        "      int y = (val >> i) & 1;",
        "      if (!nxt[p][y]) {",
        "        p = nxt[p][y ^ 1];",
        "        ans += 1 << i;",
        "      } else {",
        "        p = nxt[p][y];",
        "      }",
        "    }",
        "    return ans;",
        "  }",
        "};"
      ],
      "description": "trie_bit_array"
    },
    "trie_bit": {
      "prefix": "trie_bit",
      "body": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "#define int int64_t",
        "",
        "struct node {",
        "  node* nxt[2];",
        "  int val;",
        "  int cnt;",
        "  node() : val(0), cnt(0) {",
        "    for (int i : {0, 1}) {",
        "      nxt[i] = nullptr;",
        "    }",
        "  }",
        "};",
        "",
        "struct trie {",
        "  node* root;",
        "  int bit;",
        "  trie() : bit(30) { root = new node(); }",
        "",
        "  void insert(int val) {",
        "    node* p = root;",
        "    for (int i = bit; ~i; --i) {",
        "      int y = (val >> i) & 1;",
        "      if (!p->nxt[y]) p->nxt[y] = new node();",
        "      ++p->nxt[y]->cnt;",
        "      p = p->nxt[y];",
        "    }",
        "  }",
        "",
        "  void remove(int val) {",
        "    node* p = root;",
        "    vector<node*> st;",
        "    for (int i = bit; ~i; --i) {",
        "      int y = (val >> i) & 1;",
        "      node* ch = p->nxt[y];",
        "      assert(ch);",
        "      if (ch->cnt == 1) {",
        "        st.emplace_back(ch);",
        "        p->nxt[y] = nullptr;",
        "      } else {",
        "        --ch->cnt;",
        "      }",
        "      p = ch;",
        "    }",
        "    for (int i = st.size() - 1; ~i; --i) {",
        "      delete st[i];",
        "    }",
        "  }",
        "",
        "  int calc(int val) {",
        "    node* p = root;",
        "    int ans = 0;",
        "    for (int i = bit; ~i; --i) {",
        "      int y = (val >> i) & 1;",
        "      if (!p->nxt[y]) {",
        "        p = p->nxt[y ^ 1];",
        "        ans += 1 << i;",
        "      } else {",
        "        p = p->nxt[y];",
        "      }",
        "    }",
        "    return ans;",
        "  }",
        "};",
        "",
        "void solve() {",
        "",
        "}",
        "",
        "signed main () {",
        "  ios::sync_with_stdio(false);",
        "  cin.tie(nullptr);",
        "  int t = 1;",
        "  // cin >> t;",
        "  while (t--) {",
        "    solve();",
        "  }",
        "  return 0;",
        "}"
      ],
      "description": "trie_bit"
    },
    "comb": {
      "prefix": "comb",
      "body": [
        "int fct[MAX];",
        "",
        "void fact() {",
        "  fct[0] = fct[1] = 1;",
        "  for (int i = 2; i < MAX; ++i) {",
        "    fct[i] = fct[i - 1] * i % MOD;",
        "  }",
        "}",
        "",
        "int comb(int a, int b) {",
        "  return fct[a] * fp(fct[b] * fct[a - b] % MOD, MOD - 2) % MOD;",
        "}"
      ],
      "description": "comb"
    },
    "totient": {
      "prefix": "totient",
      "body": [
        "void phi_1_to_n(int n) {",
        "  vector<int> phi(n + 1);",
        "  for (int i = 0; i <= n; i++)",
        "    phi[i] = i;",
        "",
        "  for (int i = 2; i <= n; i++) {",
        "    if (phi[i] == i) {",
        "      for (int j = i; j <= n; j += i)",
        "        phi[j] -= phi[j] / i;",
        "    }",
        "  }",
        "}"
      ],
      "description": "totient"
    },
    "phi": {
      "prefix": "phi",
      "body": [
        "ll phi(ll x) {",
        "    ll ans = x;",
        "    for(ll i = 2ll; i * i <= x; i++) {",
        "        if (x % i == 0) {",
        "            while (x % i == 0) {",
        "\t\t\t\tx /= i;",
        "\t\t\t}",
        "            ans -= (ans / i);",
        "        }",
        "    }",
        "    if (x > 1ll) {",
        "\t\tans -= ans / x;",
        "\t}",
        "    return ans;",
        "}"
      ],
      "description": "phi"
    },
    "matrix": {
      "prefix": "matrix",
      "body": [
        "// template from tourist",
        "template <typename T, size_t N, size_t M, size_t K>",
        "array<array<T, K>, N> operator*(const array<array<T, M>, N>& a, const array<array<T, K>, M>& b) {",
        "  array<array<T, K>, N> c;",
        "  for (size_t i = 0; i < N; i++) {",
        "    for (size_t j = 0; j < K; j++) {",
        "      c[i][j] = 0;",
        "      for (size_t k = 0; k < M; k++) {",
        "        c[i][j] += a[i][k] * b[k][j];",
        "      }",
        "    }",
        "  }",
        "  return c;",
        "}",
        "",
        "template <typename T>",
        "vector<vector<T>> operator*(const vector<vector<T>>& a, const vector<vector<T>>& b) {",
        "  if (a.empty() || b.empty()) {",
        "    return {{}};",
        "  }",
        "  vector<vector<T>> c(a.size(), vector<T>(b[0].size()));",
        "  for (int i = 0; i < static_cast<int>(c.size()); i++) {",
        "    for (int j = 0; j < static_cast<int>(c[0].size()); j++) {",
        "      c[i][j] = 0;",
        "      for (int k = 0; k < static_cast<int>(b.size()); k++) {",
        "        c[i][j] += a[i][k] * b[k][j];",
        "      }",
        "    }",
        "  }",
        "  return c;",
        "}",
        "",
        "template <typename T>",
        "vector<vector<T>>& operator*=(vector<vector<T>>& a, const vector<vector<T>>& b) {",
        "  return a = a * b;",
        "}",
        "",
        "template <typename T, typename U>",
        "vector<vector<T>> power(const vector<vector<T>>& a, const U& b) {",
        "  assert(b >= 0);",
        "  vector<U> binary;",
        "  U bb = b;",
        "  while (bb > 0) {",
        "    binary.push_back(bb & 1);",
        "    bb >>= 1;",
        "  }",
        "  vector<vector<T>> res(a.size(), vector<T>(a.size()));",
        "  for (int i = 0; i < static_cast<int>(a.size()); i++) {",
        "    res[i][i] = 1;",
        "  }",
        "  for (int j = (int) binary.size() - 1; j >= 0; j--) {",
        "    res *= res;",
        "    if (binary[j] == 1) {",
        "      res *= a;",
        "    }",
        "  }",
        "  return res;",
        "}"
      ],
      "description": "matrix"
    }
  }